// Copyright (c) 2019-present, Magic Leap, Inc. All Rights Reserved.
// Use of this file is governed by the Developer Agreement, located
// here: https://auth.magicleap.com/terms/developer
/*
This file includes software generated by a third party and received by Magic Leap, Inc. 
Accordingly, third party license terms may govern aspects of this software.
Accompanying documentation may provide further information.

This file may also include software written by or on behalf of Magic Leap, 
including software modifications to the third party software. 
Such software is Copyright (c) 2022 Magic Leap, Inc. All Rights Reserved.
Such software is, and remains the property of Magic Leap. 
The intellectual and technical concepts contained in such software is proprietary to Magic Leap 
and may be covered by U.S. and Foreign Patents, patents in process, and are protected by trade secret or copyright law. 
You may use this file to develop and test code that is compatible with Magic Leap’s mixed reality technology platform
(including Magic Leap’s mixed reality hardware device(s) manufactured by or on behalf of Magic Leap and Magic Leap’s operating systems), 
and distribute this file as incorporated into such code.

To the extent permitted by any relevant third party license terms, 
MAGIC LEAP, INC. PROVIDES THE SOFTWARE IN THIS FILE "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
IN NO EVENT SHALL MAGIC LEAP, INC. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*
This word prediction is a faithful port from the Javascript-based word prediction engine
of Mozilla's Phone UX for the Boot to Geck (B2G) project called Gaia
https://github.com/mozilla-b2g/gaia
The original licensing info is here: https://github.com/mozilla-b2g/gaia/blob/master/LICENSE
*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.IO;

namespace MagicLeap.DesignToolkit.Keyboard
{
    public class Prediction
    {
        public static readonly int CACHE_SIZE = 255; // how many suggestions to remember

        // Weights of various permutations we do when matching input
        public static readonly float VARIANT_FORM_MULTIPLIER = 0.99f; // slightly prefer exact match
        public static readonly float PUNCTUATION_INSERTION_MULTIPLIER = 0.95f; // apostrophes are almost free
        public static readonly float NEARBY_KEY_REPLACEMENT_MULTIPLIER = 1f; // adjusted by actual distance
        public static readonly float TRANSPOSITION_MULTIPLIER = 0.3f;
        public static readonly float INSERTION_MULTIPLIER = 0.3f;
        public static readonly float SUBSTITUTION_MULTIPLIER = 0.2f; // for keys that are not nearby
        public static readonly float DELETION_MULTIPLIER = 0.1f;
        public static readonly float ZERO_CORRECTION_PREFIX_MULTIPLIER = 10.0f;

        // Profane words don't have a frequency themselves, so we bump their
        // frequency to a value which will make it pop up (only do if matches input)
        // 15 is a value that still allows very obvious corrections to be made
        // see #803189 for more information.
        public static readonly float PROFANE_INPUT_MATCH_WEIGHT = 15.0f;

        // If we can't find enough exact word matches for the user's input
        // we have to expand some of the candidates we found into complete
        // words. But we want words that are close in length to the user's
        // input. The most frequent word beginning with r in the en.us wordlist is
        // received, but we don't want that as a suggestion if the user just
        // type r. We want things like red and run. So for each extra character
        // we have to add, we multiply the weight by this amount.
        public static readonly float WORD_EXTENSION_MULTIPLIER = 0.4f;

        // How many candidates do we consider before pausing with a setTimeout()?
        // Smaller values make the prediction code more interruptible and
        // possibly result in a more responsive UX. Larger values may reduce the
        // total time required to get predictions
        public static readonly int CANDIDATES_PER_BATCH = 10;
        public HashSet<char> ValidChars;
        public bool Initialized;
        private byte[] _tree;
        private int _maxWordLength;
        private SortedDictionary<UInt16, UInt32> _characterTable;
        private SortedDictionary<UInt16, string> _variants;
        private SortedDictionary<UInt16, UInt16> _rootForm;
        private LRUCache _cache;
        private volatile Task<List<Suggestion>> _curPredictTask = null;

        public Prediction()
        {
            _characterTable = new SortedDictionary<UInt16, UInt32>();
            _variants = new SortedDictionary<UInt16, string>();
            _rootForm = new SortedDictionary<UInt16, UInt16>();
            ValidChars = new HashSet<char>();
            Initialized = false;
        }

        private UInt32 ReadUInt32(byte[] file, int offset)
        {
            return (UInt32) ((file[offset] << 24) +
                             (file[offset + 1] << 16) +
                             (file[offset + 2] << 8) +
                             file[offset + 3]);
        }

        private UInt16 ReadUInt16(byte[] file, int offset)
        {
            return (UInt16) ((file[offset] << 8) + file[offset + 1]);
        }

        public void Init(TextAsset dictAsset)
        {
            byte[] dictBytes = dictAsset.bytes;
            try
            {
                SetDictionary(dictBytes);
                Initialized = true;
            }
            catch (Exception e)
            {
                Debug.Log(e.Message);
            }
        }

        // This function is called to pass our dictionary to us as an ArrayBuffer.
        public void SetDictionary(byte[] file)
        {
            _cache = new LRUCache(CACHE_SIZE);
            _characterTable.Clear();
            _variants.Clear();
            _rootForm.Clear();
            ValidChars.Clear();
            Initialized = false;
            if (ReadUInt32(file, 0) != 0x46784F53 || // "FxOS"
                ReadUInt32(file, 4) != 0x44494354) // "DICT"
            {
                throw new Exception("Invalid dictionary file");
            }
            if (ReadUInt32(file, 8) != 1)
            {
                throw new Exception("Unknown dictionary version");
            }
            _maxWordLength = file[12] + 1;
            Debug.Log("Max Word Length: " + _maxWordLength);
            int numEntries = ReadUInt16(file, 13);
            Debug.Log("Num of Entries: " + numEntries);
            for (int i = 0; i < numEntries; i++)
            {
                int offset = 15 + i * 6;
                _characterTable[ReadUInt16(file, offset)] = ReadUInt32(file, offset + 2);
            }
            int treeOffset = 15 + numEntries * 6;
            int treeLength = file.Length - treeOffset;
            _tree = new byte[treeLength];

            // The dictionary data begins right after the character table
            Array.Copy(file, treeOffset, _tree, 0, treeLength);

            // The rest of this function processes the character table to create a
            // list of variant forms that we'll accept for each character in the
            // dictionary. Variants cover case differences and unaccented forms of
            // accented letters. Characters with no variants are considered word
            // internal punctuation like apostophes and hyphens.

            // Map from lowercase ASCII to all known accented forms of the letter
            var rootToAccentedForm = new Dictionary<char, string>()
            {
                {'a', "ÁáĂăǍǎÂâÄäȦȧẠạȀȁÀàẢảȂȃĀāĄąÅåḀḁȺⱥÃãǼǽǢǣÆæ"},
                {'b', "ḂḃḄḅƁɓḆḇɃƀƂƃ"},
                {'c', "ĆćČčÇçĈĉĊċƇƈȻȼ"},
                {'d', "ĎďḐḑḒḓḊḋḌḍƊɗḎḏĐđƋƌð"},
                {'e', "ÉéĔĕĚěȨȩÊêḘḙËëĖėẸẹȄȅÈèẺẻȆȇĒēĘę"},
                {'f', "ḞḟƑƒ"},
                {'g', "ǴǵĞğǦǧĢģĜĝĠġƓɠḠḡǤǥ"},
                {'h', "ḪḫȞȟḨḩĤĥⱧⱨḦḧḢḣḤḥĦħ"},
                {'i', "ÍíĬĭǏǐÎîÏïỊịȈȉÌìỈỉȊȋĪīĮįƗɨĨĩḬḭı"},
                {'j', "ĴĵɈɉ"},
                {'k', "ḰḱǨǩĶķⱩⱪꝂꝃḲḳƘƙḴḵꝀꝁ"},
                {'l', "ĹĺȽƚĽľĻļḼḽḶḷⱠⱡꝈꝉḺḻĿŀⱢɫŁł"},
                {'m', "ḾḿṀṁṂṃⱮɱ"},
                {'n', "ŃńŇňŅņṊṋṄṅṆṇǸǹƝɲṈṉȠƞÑñ"},
                {'o', "ÓóŎŏǑǒÔôÖöȮȯỌọŐőȌȍÒòỎỏƠơȎȏꝊꝋꝌꝍŌōǪǫØøÕõŒœ"},
                {'p', "ṔṕṖṗꝒꝓƤƥⱣᵽꝐꝑ"},
                {'q', "Ꝗꝗ"},
                {'r', "ŔŕŘřŖŗṘṙṚṛȐȑȒȓṞṟɌɍⱤɽ"},
                {'s', "ŚśŠšŞşŜŝȘșṠṡṢṣß"},
                {'t', "ŤťŢţṰṱȚțȾⱦṪṫṬṭƬƭṮṯƮʈŦŧ"},
                {'u', "ÚúŬŭǓǔÛûṶṷÜüṲṳỤụŰűȔȕÙùỦủƯưȖȗŪūŲųŮůŨũṴṵ"},
                {'v', "ṾṿƲʋṼṽ"},
                {'w', "ẂẃŴŵẄẅẆẇẈẉẀẁⱲⱳ"},
                {'x', "ẌẍẊẋ"},
                {'y', "ÝýŶŷŸÿẎẏỴỵỲỳƳƴỶỷỾỿȲȳɎɏỸỹ"},
                {'z', "ŹźŽžẐẑⱫⱬŻżẒẓȤȥẔẕƵƶ"},
                {'α', "άΆ"},
                {'ε', "έΈ"},
                {'η', "ήΉ"},
                {'ι', "ίϊΐΊΪ"},
                {'ο', "όΌ"},
                {'υ', "ύϋΰΎΫ"},
                {'ω', "ώΏ"},
                {'$', "$"}
            };

            // The reverse mapping from accented forms to the normalized ASCII form
            var accentedFormToRoot = new Dictionary<char, char>();
            foreach (KeyValuePair<char, string> pair in rootToAccentedForm)
            {
                string val = pair.Value;
                foreach (char c in val)
                {
                    accentedFormToRoot[c] = pair.Key;
                    ;
                }
            }
            Debug.Log("accentedFormToRoot has size of: " + accentedFormToRoot.Count);

            // Print character table
            Debug.Log("characterTable has size of: " + _characterTable.Count);
            StringBuilder msg = new StringBuilder("_characterTable: ");
            foreach (var pair in _characterTable)
            {
                msg.Append(pair.Key + ": " + pair.Value + ",  ");
            }
            Debug.Log(msg.ToString());
            msg.Clear();

            // Now through all the characters that appear in the dictionary
            // and figure out their variant forms.
            foreach (KeyValuePair<UInt16, UInt32> pair in _characterTable)
            {
                UInt16 charcode = pair.Key;

                // Start off by with an empty set of variants for each character.
                StringBuilder curVariants = new StringBuilder();

                // Handle upper and lowercase forms
                char ch = (char) charcode;
                char upper = Char.ToUpper(ch);
                char lower = Char.ToLower(ch);
                if (upper != ch)
                {
                    curVariants.Append(upper);
                    // It is not upper case it is probably the root form.
                    // If it is an accented character, we'll override this below
                    _rootForm[charcode] = charcode;
                }
                if (lower != ch)
                {
                    curVariants.Append(lower);
                    _rootForm[charcode] = (UInt16) lower;
                }

                // Handle accented forms
                if (accentedFormToRoot.ContainsKey(ch))
                {
                    char root = accentedFormToRoot[ch];
                    _rootForm[charcode] = (UInt16) root;

                    // The root form and its uppercase version are variants we'll
                    // accept in user input instead of this accented character.
                    curVariants.Append(root);
                    curVariants.Append(Char.ToUpper(root));
                }

                // If (curVariants.Length > 0)
                _variants[charcode] = curVariants.ToString();

                //Debug.Log("Variants for " + ch + ": " + _variants[charcode]);
                //Debug.Log("Root form of " + ch + ": " + //((char)(_rootForm[charcode])).ToString());
                //    (_rootForm.ContainsKey(charcode) ? ((char)(_rootForm[charcode])).ToString() : "null"));
            }
            GenerateValidChars();
            PrintPreProcessResult();
        }

        private void GenerateValidChars()
        {
            ValidChars.Clear();
            foreach (KeyValuePair<UInt16, string> pair in _variants)
            {
                ValidChars.Add((char) pair.Key);
                foreach (char ch in pair.Value)
                {
                    ValidChars.Add(ch);
                }
                // Could add nearby keys here
            }
        }

        public async Task<List<Suggestion>> LaunchPredict(string input, int maxSuggestions,
            int maxCandidates, int maxCorrections, CancellationToken token, CancellationTokenSource tokenSrc)
        {
            if (token.IsCancellationRequested)
            {
                Debug.Log("Cancellation request received at the beginning of LaunchPredict");
                token.ThrowIfCancellationRequested();
                return null;
            }
            try
            {
                _curPredictTask = Predict(input, maxSuggestions, maxCandidates, maxCorrections, token);
                await _curPredictTask;
                Debug.Log("Predict finished for " + input);
                PrintResult(_curPredictTask.Result);
                return _curPredictTask.Result;
            }
            catch (OperationCanceledException)
            {
                Debug.Log("Cancellation exception encountered inside LaunchPredict for input: " + input);
                token.ThrowIfCancellationRequested();
                return null;
            }
            finally
            {
                tokenSrc.Dispose();
            }
        }

        private async Task<List<Suggestion>> Predict(string input, int maxSuggestions,
            int maxCandidates, int maxCorrections, CancellationToken token)
        {
            if (token.IsCancellationRequested)
            {
                Debug.Log("Cancellation request received at the beginning of Predict for input: " + input);
                token.ThrowIfCancellationRequested();
                return null;
            }
            try
            {
                await Task.Yield();
                if (_tree == null || _tree.Length == 0)
                {
                    throw new Exception("Not properly initialized");
                }

                // The search algorithm compares the user's input to the dictionary tree
                // data structure and generates a set of candidates incrementally,
                // character by character.
                // This variable will store the set of candidates we're evaluating as we
                // do a breadth first search of the dictionary tree and allows us to
                // pull out the best candidates first for further evaluation.
                var candidates = new BoundedPriorityQueue<Candidate>(maxCandidates);

                // This is where we store the best complete suggestions we've found so far.
                var suggestions = new BoundedPriorityQueue<Suggestion>(maxSuggestions);

                // If the first letter of the input is a capital letter, then we
                // want to capitalize the first letter of all the suggestions.
                // We do this here rather than in latin.js so that we can filter out
                // repeated suggestions that come in both upper and lowercase forms
                bool capitalize = char.IsUpper(input[0]);
                string cacheKey = input +
                                  ',' + maxSuggestions +
                                  ',' + maxCandidates +
                                  ',' + maxCorrections;
                var task = GetSuggestions(cacheKey, input, maxSuggestions, maxCandidates, maxCorrections, capitalize,
                    candidates, suggestions, token);
                await task;
                return task.Result;
            }
            catch (OperationCanceledException)
            {
                Debug.Log("Cancellation exception encountered inside Predict for input: " + input);
                token.ThrowIfCancellationRequested();
                return null;
            }
        }

        private async Task<List<Suggestion>> GetSuggestions(string cachekey, string input,
            int maxSuggestions, int maxCandidates, int maxCorrections, bool capitalize,
            BoundedPriorityQueue<Candidate> candidates, BoundedPriorityQueue<Suggestion> suggestions,
            CancellationToken token)
        {
            // Check the cache. If we've seen this input recently we can return
            // suggestions right away.
            List<Suggestion> cached_suggestions = _cache.Get(cachekey);
            if (cached_suggestions != null)
            {
                Debug.Log("cache hit, returning result");
                return cached_suggestions;
            }
            Debug.Log("Entering GetSuggestion with input: " + input);
            if (token.IsCancellationRequested)
            {
                Debug.Log("Cancellation request received at the beginning of GetSuggestions for input: " + input);
                token.ThrowIfCancellationRequested();
                return null;
            }
            try
            {
                await Task.Yield();
                // Check length and check for invalid characters. If the input is
                // bad, we can reject it right away.
                if (input.Length > _maxWordLength)
                {
                    Debug.Log("input length is larger than max lenght allowed, aborting");
                    return null;
                }
                foreach (char ch in input)
                {
                    if (!ValidChars.Contains(ch))
                    {
                        Debug.Log("Valid chars do not contain " + ch.ToString() + ", aborting");
                        return null;
                    }
                }
                AddCandidate(0, input, "", 1.0f, 1.0f, 0, candidates, suggestions);
                var task = ProcessCandidates(cachekey, input, capitalize, maxCorrections, candidates, suggestions,
                    token);
                await task;

                //Debug.Log("At the end of GetSuggestions: ");
                //PrintStatus(candidates, suggestions);
                return suggestions.items_;
            }
            catch (OperationCanceledException)
            {
                Debug.Log("Cancellation exception encountered inside GetSuggestions for input: " + input);
                token.ThrowIfCancellationRequested();
                return null;
            }
        }

        // Add a candidate to the list of promising candidates if frequency *
        // multiplier is high enough. A candidate includes a pointer (byte offset)
        // to a node in the tree, the portion of the user's input that has not yet
        // been considered, the output string that has been generated so far, a
        // number based on the highest frequency word that begins with the
        // output we've generated, a multipler that adjusts that frequency based
        // on how much we've modified the user's input, and a number that
        // indicates how many times we've already corrected the user's input for
        // this candidate.
        private void AddCandidate(int pointer, string remaining, string output,
            float multiplier, float frequency, int corrections,
            BoundedPriorityQueue<Candidate> candidates, BoundedPriorityQueue<Suggestion> suggestions)
        {
            float weight = frequency * multiplier;

            // If no major corrections have been made to this candidate, then
            // artificially increase its weight so that it appears in the
            // candidates list before any corrected candidates. This should
            // ensure that if the user is typing an infrequent word (but typing it
            // correctly), we don't bump the actual word off the list if there are
            // lots of frequent words that have similar spellings. The artificial
            // weight does not carry through to the list of words, so more frequent
            // words may still be predicted instead of the user's input when the user
            // is typing an infrequent word. But we shouldn't ever not be able to
            // find the user's input as a valid word.  Adding letters to the
            // end of partial input does not count as a correction so we also
            // test the multiplier so that we don't boost the weight of every
            // extension. But we do allow one letter to be added on and still
            // get the extra weight.
            if (corrections == 0 && multiplier > WORD_EXTENSION_MULTIPLIER * WORD_EXTENSION_MULTIPLIER)
                weight += 100f;
            // Give it a little boost if corrections are 0 but more than one
            // character has been added to the input, boost depends on freq
            else if (corrections == 0)
                weight += ((frequency / 32.0f) * ZERO_CORRECTION_PREFIX_MULTIPLIER);

            // If this candidate could never become a suggestion, don't add it
            if (weight <= suggestions.threshold_)
                return;
            candidates.Add(new Candidate(pointer, remaining, output, multiplier, weight, corrections), weight);
        }

        private void AddSuggestion(string suggestionText, float weight, bool capitalize,
            BoundedPriorityQueue<Candidate> candidates, BoundedPriorityQueue<Suggestion> suggestions)
        {
            // If the input was capitalized, capitalize the suggestion
            string realSuggestionText = capitalize
                ? Char.ToUpper(suggestionText[0]).ToString() + suggestionText.Substring(1)
                : suggestionText;

            // Make sure we don't already have the suggestion in the queue
            for (int i = 0; i < suggestions.items_.Count; i++)
            {
                if (suggestions.items_[i].TextToType == realSuggestionText)
                {
                    // If the version we already have has higher weight, skip this one
                    if (suggestions.priorities_[i] >= weight) return;
                    else suggestions.RemoveItemAt(i);
                    break;
                }
            }
            suggestions.Add(new Suggestion(realSuggestionText, weight), weight);
        }

        // Take the highest-ranked candidate from the list of candidates and
        // process it. (This will often add more candidates to the list). After
        // we've processed a batch of candidates this way, use setTimeout() to
        // schedule the processing of the next batch after returning to the
        // event loop. If there are no more candidates or if the highest ranked
        // one is not highly ranked enough, then we're done finding all the
        // possible candidates, and thus, we're doen for making suggestions.
        private async Task ProcessCandidates(string cachekey, string origInput, bool capitalize, int maxCorrections,
            BoundedPriorityQueue<Candidate> candidates, BoundedPriorityQueue<Suggestion> suggestions,
            CancellationToken token)
        {
            await Task.Yield();
            if (token.IsCancellationRequested)
            {
                Debug.Log("Cancellation request received in ProcessCandidates outside " +
                          "batch loop for input: " + origInput);
                token.ThrowIfCancellationRequested();
            }
            for (int count = 0; count < CANDIDATES_PER_BATCH; count++)
            {
                if (token.IsCancellationRequested)
                {
                    Debug.Log("Cancellation request received in ProcessCandidates " +
                              "at the beginning of batch loop for input: " + origInput);
                    token.ThrowIfCancellationRequested();
                }
                Nullable<Candidate> candidate = candidates.Remove();

                // If there are no more candidates, or if the weight isn't
                // high enough, we're done.
                if (candidate == null || candidate.Value.weight_ <= suggestions.threshold_)
                {
                    _cache.Add(cachekey, suggestions.items_);
                    return;
                }
                Process(candidate.Value, origInput, capitalize, maxCorrections, candidates, suggestions);

                // If the predicted suggestions don't seem right, uncomment these
                // lines to see how the call to process() modifies the set of
                // candiates at each step. The output is verbose, but with careful
                // study it reveals what is going on in the algorithm.
                StringBuilder builder = new StringBuilder("");
                for (var i = 0; i < candidates.items_.Count; i++)
                {
                    builder.Append(candidates.priorities_[i] + " "
                                                             + candidates.items_[i].output_ + " " +
                                                             +candidates.items_[i].multiplier_ + ",  ");
                }
            }
            try
            {
                var task = ProcessCandidates(
                    cachekey, origInput, capitalize, maxCorrections, candidates, suggestions, token);
                await task;
            }
            catch (OperationCanceledException)
            {
                Debug.Log("Cancellation Exception encountered " +
                          "inside ProcessCandidates for input: " + origInput);
                token.ThrowIfCancellationRequested();
            }
        }

        private void Process(Candidate candidate, string origInput, bool capitalize, int maxCorrections,
            BoundedPriorityQueue<Candidate> candidates, BoundedPriorityQueue<Suggestion> suggestions)
        {
            string remaining = candidate.input_;
            string output = candidate.output_;
            float multiplier = candidate.multiplier_;
            int corrections = candidate.corrections_;

            // The next character of the remainder of user's input
            char curChar = remaining.Length > 0 ? remaining[0] : '\0';
            UInt16 curCharCode = remaining.Length > 0 ? (UInt16) remaining[0] : (UInt16) 0;
            int curr = candidate.pointer_;
            while (curr != -1)
            {
                TSTNode node = ReadNode(curr);

                // How common is the most common word under this node?
                float frequency = (float) node.freq_;
                float weight = frequency * multiplier;

                // If this node does not have a high enough weight to make it into
                // the list of candidates, we don't need to continue. None of the
                // nodes that follow in the next pointer linked list will have a
                // higher weight than this one.
                // Note however, that we only use this shortcut if we've already
                // made at least one correction because uncorrected matches are given
                // high weight by addCandidate.
                if (corrections > 0 && weight <= candidates.threshold_) break;

                // If we generate new candidates from this node, this is what
                // their output string will be
                string newOutput = output + ((char) node.ch_).ToString();

                // The various ways (i.e. GrowOperations) we can generate new candidates
                // from this node follow. Note that each one can have a different
                // associated multiplier. And note that some are considered
                // corrections. To prevent explosive growth in the number of candidates,
                // we limit the number of corrections allowed on any candidate.

                // If there isn't any more input from the user, then we'll try to
                // extend the output we've already got to find a complete word as a
                // suggestion. But we apply a penalty for each character we add so that
                // shorter completions are favored over longer completions
                if (remaining.Length == 0)
                {
                    // If a word ends here, add it to the queue of suggestions
                    if (node.ch_ == (UInt16) 0)
                    {
                        // Only suggest profane (freq == 1) words if the input is
                        // already the same
                        if (node.freq_ == 1 &&
                            origInput.ToUpper() == output.ToUpper())
                        {
                            // Profane words have very low frequency themselves.
                            // To make sure they pop up we bump the frequency
                            AddSuggestion(output, PROFANE_INPUT_MATCH_WEIGHT, capitalize,
                                candidates, suggestions);
                        }
                        else if (node.freq_ != 1)
                        {
                            AddSuggestion(output, weight, capitalize, candidates, suggestions);
                        }
                        curr = node.next_;
                        continue;
                    }

                    // Insertion-Extend GrowOperation:
                    // Otherwise, extend the candidate with the current node. We
                    // reduce the multiplier, but do not count this as a correction so
                    // that we can extend candidates as far as needed to find suggestions.
                    // This is like in the sense of auto completion.
                    // if (VERBOSE) writer_.WriteLine("Insertion-Extend GrowOperation:");
                    AddCandidate(node.center_, remaining, newOutput, multiplier * WORD_EXTENSION_MULTIPLIER,
                        frequency, corrections, candidates, suggestions);

                    // If there isn't any more input then we don't want to consider
                    // any of the other possible corrections below.
                    curr = node.next_;
                    continue;
                }

                // Handle the case where this node marks the end of a word.
                if (node.ch_ == (UInt16) 0)
                {
                    // Deletion-AtEnd GrowOperation
                    // If there is just one more character of user input remaining,
                    // maybe the user accidentally typed an extra character at the
                    // end, so try just dropping the last character. Note that this
                    // case is unique in that instead of following the center pointer
                    // it revisits the same node just without the one remaining
                    // character of input.
                    if (remaining.Length == 1)
                    {
                        // if (VERBOSE) writer_.WriteLine("Deletion-AtEnd GrowOperation:");
                        AddCandidate(curr, "", output, multiplier * DELETION_MULTIPLIER, frequency, corrections + 1,
                            candidates, suggestions);
                    }
                    curr = node.next_;
                    continue;
                }

                // If we get to here, we know that we're still processing the user's
                // input and that there is a character associated with this node.

                // These next several GrowOperations are all in disjoint if/else chains,
                // meaning that they're not mutually exclusive.
                // GrowOps within a if/else chain add the same candidate, so it never
                // makes sense for more than one of them to run.
                // But note that it is possible for such GrowOps to happen more than one
                // way, so we have to be sure to do the tests in highest to lowest
                // multiplier order.

                // Match GrowOperation: an exact match on this character
                if (node.ch_ == curCharCode)
                {
                    // if (VERBOSE) writer_.WriteLine("Match GrowOperation:");
                    AddCandidate(node.center_, remaining.Substring(1), newOutput, multiplier, frequency, corrections,
                        candidates, suggestions);
                }
                else if (_variants[node.ch_].IndexOf((char) curCharCode) != -1)
                {
                    // Substitution-Variant GrowOperation:
                    // The user's input is a variant form of the character in this
                    // node, so we'll accept that input as a substitute for the node
                    // character. This covers case differences and unaccented forms of
                    // accented characters. (We don't accept accented forms typed by
                    // the user as variants of unaccented characters in the
                    // dictionary, however.)
                    // if (VERBOSE) writer_.WriteLine("Substitution-Variant GrowOperation:");
                    AddCandidate(node.center_, remaining.Substring(1), newOutput, multiplier * VARIANT_FORM_MULTIPLIER,
                        frequency, corrections, candidates, suggestions);
                }
                else if (corrections < maxCorrections)
                {
                    // If we haven't made any corrections on this candidate yet, try
                    // substituting the character from this node for the current
                    // character in the user's input. If the two keys are near each
                    // other on the keyboard, then we do this with higher weight than
                    // if they are distant.
                    //UInt16 rootNode = _rootForm[(UInt16)node.ch_];
                    //UInt16 rootInput = _rootForm[curCharCode];
                    if (output.Length > 0)
                    {
                        // Substitution-Any GrowOperation:
                        // If it wasn't a nearby key, try substituting it anyway, but
                        // with a much lower weight. This handles the case where the
                        // user just doesn't know how to spell the word. We assume that
                        // the user knows the correct first letter of the word.
                        AddCandidate(node.center_, remaining.Substring(1), newOutput,
                            multiplier * SUBSTITUTION_MULTIPLIER,
                            frequency, corrections + 1, candidates, suggestions);
                    }
                }

                // Now we try some other tests that generate different candidates
                // than the above. These involve insertion, deletion or
                // transposition. Note that to avoid exponential blow-up of the
                // search space, we generally only allow maxCorrections (usually 1)
                // correction per candidate.

                // First, just try inserting this character. Maybe the user forgot
                // to type it or omitted punctuation on purpose. If this character
                // has no variants, then it is a punctuation character and we allow
                // it to be inserted with a high multiplier and no correction
                // penalty. If it is not word punctuation, then the insertion is
                // more costly. Also: assume that the user got the first character
                // correct and don't insert at position 0.
                if (!_variants.ContainsKey(node.ch_) ||
                    _variants[node.ch_] == null ||
                    _variants[node.ch_].Length == 0) // If it is a punctuation character
                {
                    // Insertion-Punctuation GrowOperation
                    AddCandidate(node.center_, remaining, // insertion, so no substring here
                        newOutput, multiplier * PUNCTUATION_INSERTION_MULTIPLIER, frequency, corrections,
                        candidates, suggestions);
                }
                else if (corrections < maxCorrections && output.Length > 0)
                {
                    // Insertion-Any GrowOperation
                    AddCandidate(node.center_, remaining, newOutput, multiplier * INSERTION_MULTIPLIER,
                        frequency, corrections + 1, candidates, suggestions);
                }

                // If there is more input after this character, and if this node of
                // the tree matches the next character of the input, try deleting
                // the current character and try transposing the two. But assume
                // that the user got their first character correct and don't mess
                // with that.
                if (corrections < maxCorrections && remaining.Length > 1 && output.Length > 0 &&
                    (node.ch_ == (UInt16) remaining[1] ||
                     _variants[node.ch_].IndexOf(remaining[1]) != -1))
                {
                    // Transposition GrowOperation
                    AddCandidate(node.center_, remaining[0].ToString() + remaining.Substring(2),
                        newOutput, multiplier * TRANSPOSITION_MULTIPLIER, frequency, corrections + 1,
                        candidates, suggestions);

                    // Deletion GrowOperation
                    AddCandidate(node.center_, remaining.Substring(2), newOutput,
                        multiplier * DELETION_MULTIPLIER, frequency, corrections + 1,
                        candidates, suggestions);
                }
                curr = node.next_;
            }
        }

        //
        // This function unpacks binary data from the dictionary and returns
        // the nodes of the dictionary tree in expanded form as JS objects.
        // See gaia/dictionaries/xml2dict.py for the corresponding code that
        // serializes the nodes of the tree into this binary format. Full
        // documentation of the binary format is in that file.
        //
        public TSTNode ReadNode(int offset)
        {
            TSTNode node = new TSTNode();
            if (offset == -1)
            {
                throw new Exception("Assertion error: followed invalid pointer");
            }
            Byte firstbyte = _tree[offset++];
            bool haschar = (firstbyte & 0x80) != 0;
            bool bigchar = (firstbyte & 0x40) != 0;
            bool hasnext = (firstbyte & 0x20) != 0;
            node.freq_ = (firstbyte & 0x1F) + 1; // frequencies range from 1 to 32
            if (haschar)
            {
                node.ch_ = (UInt16) (_tree[offset++]);
                if (bigchar)
                {
                    node.ch_ = (UInt16) (((UInt16)(node.ch_) << 8) + ((UInt16)_tree[offset++]));
                }
            }
            else
            {
                node.ch_ = (UInt16) 0;
            }
            if (hasnext)
            {
                node.next_ = (_tree[offset++] << 16) + (_tree[offset++] << 8) + _tree[offset++];
            }
            else
            {
                node.next_ = -1;
            }
            if (haschar)
            {
                node.center_ = offset;
            }
            else
            {
                node.center_ = -1;
            }
            return node;
        }

        public void PrintResult(List<Suggestion> resultSuggestions)
        {
            StringBuilder builder = new StringBuilder("Result suggestions are: ");
            if (resultSuggestions == null)
            {
                Debug.Log("no valid result at all");
                return;
            }
            Debug.Log("result length is: " + resultSuggestions.Count);
            foreach (Suggestion suggestion in resultSuggestions)
            {
                builder.Append("text: " + suggestion.TextToType + ", weight: " + suggestion.weight_ + "; ");
            }
            Debug.Log(builder.ToString());
        }

        public void PrintStatus(BoundedPriorityQueue<Candidate> candidates,
            BoundedPriorityQueue<Suggestion> suggestions)
        {
            StringBuilder builder = new StringBuilder("Current candidates are: ");
            for (int i = 0; i < candidates.items_.Count; i++)
            {
                builder.Append(candidates.items_[i].ToStr());
                builder.Append("with priority of: " + candidates.priorities_[i] + "; ");
            }
            Debug.Log(builder.ToString());
            builder.Clear();
            builder.Append("Current suggestions are: ");
            for (int i = 0; i < suggestions.items_.Count; i++)
            {
                builder.Append(suggestions.items_[i].ToStr());
                builder.Append("with priority of: " + suggestions.priorities_[i] + "; ");
            }
            Debug.Log(builder.ToString());
        }

        public void PrintPreProcessResult()
        {
            StringBuilder builder = new StringBuilder("PreProcess result: ");
            builder.Append("_variants: ");
            builder.Append("length is: " + _variants.Count + ".  ");
            foreach (var pair in _variants)
            {
                builder.Append(pair.Key + ": " + pair.Value + ",  ");
            }
            Debug.Log(builder.ToString());
            builder.Clear();
            builder.Append("ValidChars: ");
            builder.Append("length is: " + ValidChars.Count);
            foreach (var ch in ValidChars)
            {
                builder.Append(ch.ToString() + ", ");
            }
            Debug.Log(builder.ToString());
        }
    }

    public struct TSTNode
    {
        public UInt16 ch_;
        public int freq_;
        public int next_;
        public int center_;
    }

    public struct Suggestion
    {
        public Suggestion(string text, float weight)
        {
            TextToType = text;
            weight_ = weight;
        }

        public string ToStr()
        {
            return "text: " + TextToType +
                   ", weight: " + weight_ +
                   "; ";
        }

        public string TextToType;
        public float weight_;
    }

    public struct Candidate
    {
        public Candidate(int pointer, string input, string output, float multiplier, float weight, int corrections)
        {
            pointer_ = pointer;
            input_ = input;
            output_ = output;
            multiplier_ = multiplier;
            weight_ = weight;
            corrections_ = corrections;
        }

        public string ToStr()
        {
            return "pointer: " + pointer_ +
                   ", input: " + input_ +
                   ", output: " + output_ +
                   ", multiplier: " + multiplier_ +
                   ", weight: " + weight_ +
                   ", corrections: " + corrections_ +
                   "; ";
        }

        public int pointer_;
        public string input_;
        public string output_;
        public float multiplier_;
        public float weight_;
        public int corrections_;
    }

    //
    // A very simple Least Recently Used cache. It depends on the fact that the
    // JavaScript for/in loop enumerates properties in order from least recently
    // to most recently added. (Note that this does not work for properties
    // that are numbers, however.)
    //
    public class LRUCache
    {
        public int maxSize_;
        public int size_;
        public Dictionary<string, List<Suggestion>> map_;
        public List<string> keys_; //A hack for a queue

        public LRUCache(int maxSize)
        {
            maxSize_ = maxSize;
            size_ = 0;
            map_ = new Dictionary<string, List<Suggestion>>();
            keys_ = new List<string>();
            if (maxSize_ == 0) throw new Exception("Max size cannot be 0!");
        }

        // Cache the key/value pair
        public void Add(string key, List<Suggestion> val)
        {
            // If the key is already in the cache, adjust the size since we'll
            // be incrementing below
            if (map_.ContainsKey(key))
            {
                size_--;
                keys_.Remove(key);
            }

            // Now insert the item
            map_[key] = val;
            keys_.Add(key);
            size_++;

            // If the size is too big delete the first property
            // This should be the least recently used because the Get()
            // method deletes and reinserts
            if (size_ > maxSize_)
            {
                string keyToDel = keys_[0];
                map_.Remove(keyToDel);
                keys_.RemoveAt(0);
                size_--;
            }
        }

        public List<Suggestion> Get(string key)
        {
            if (map_.ContainsKey(key)) // If the key is in the cache
            {
                List<Suggestion> result = map_[key]; // Get the value
                keys_.Remove(key); // Delete the key
                keys_.Add(key); // And re-insert to make it most recent
                return result;
            }
            return null;
        }
    }

    public class BoundedPriorityQueue<T> where T : struct
    {
        public int maxSize_;
        public float threshold_;
        public List<T> items_;
        public List<float> priorities_;

        public BoundedPriorityQueue(int maxSize)
        {
            maxSize_ = maxSize;
            threshold_ = 0.0f;
            items_ = new List<T>();
            priorities_ = new List<float>();
            if (maxSize_ == 0)
                throw new Exception("Cannot create BoundedPriorityQueue with maxSize_==0");
        }

        public bool Add(T item, float priority, StreamWriter writer = null)
        {
            if (items_.Count == maxSize_)
            {
                if (priority <= threshold_) // Reject the item.
                {
                    if (writer != null) writer.WriteLine("rejecting the item when adding to priority queue");
                    return false;
                }
                else // Make room for it.
                {
                    items_.RemoveAt(items_.Count - 1);
                    priorities_.RemoveAt(priorities_.Count - 1);
                }
            }

            // Search to find the insertion point for this new item
            int index = 0;
            if (priorities_.Count > 60)
            {
                // Binary search only for relatively long arrays.
                // See http://jsperf.com/linear-or-binary-search for perf data.
                int start = 0, end = priorities_.Count;
                while (start != end)
                {
                    int mid = (start + end) / 2;
                    if (priority > priorities_[mid])
                    {
                        end = mid;
                    }
                    else
                    {
                        start = mid + 1;
                    }
                }
                index = start;
            }
            else
            {
                for (int i = 0, n = priorities_.Count; i <= n; i++)
                {
                    if (i == n || priority > priorities_[i])
                    {
                        index = i;
                        break;
                    }
                }
            }
            items_.Insert(index, item);
            priorities_.Insert(index, priority);
            threshold_ = priorities_.Count == maxSize_ ? priorities_[maxSize_ - 1] : 0f;
            return true;
        }

        public Nullable<T> Remove()
        {
            if (items_.Count == 0 || priorities_.Count == 0) return null;
            T result = items_[0];
            items_.RemoveAt(0);
            priorities_.RemoveAt(0);
            threshold_ = priorities_.Count == maxSize_ ? priorities_[maxSize_ - 1] : 0f;
            return result;
        }

        public bool RemoveItemAt(int index)
        {
            if (index >= priorities_.Count || index >= items_.Count) return false;
            priorities_.RemoveAt(index);
            items_.RemoveAt(index);
            threshold_ = priorities_.Count == maxSize_ ? priorities_[maxSize_ - 1] : 0f;
            return true;
        }
    }
}